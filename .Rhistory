knitr::opts_chunk$set(echo=TRUE, cache=FALSE, results="hide", message=FALSE, warning=FALSE)
# Several libraries and util functions from my GitHub
source("https://raw.githubusercontent.com/Leejere/r-setup/main/r_setup.r")
# Some other libraries to be used
library(Hmisc)
library(rgeoda)
library(BAMMtools)
library(DAAG)
library(car)  #to calculate VIF
library(MASS)
library(rsq)
# A 5-scale palette based off of the hero palette color
palette_blue_5 = list('#ffffff', '#c6c7eb', '#8e8fd7', '#5557c3', '#353797')
hs_value = st_read("data/Regression Data.shp") %>%
st_transform(crs)
View(hs_value)
df = st_read("data/Regression Data.shp") %>%
st_transform(crs) %>%
dplyr::select(bg_id = AREAKEY, # Block Group ID
md_housing_value = MEDHVAL, # Median Housing Value (owner-occupied)
pct_bachelor = PCTBACHMORE, # Pct of residents w/ bachelor's +
pct_vacant = PCTVACANT, # Pct of hs units that are vacant
n_poverty = NBELPOV100, # Number of hhs below poverty line
md_hh_income = MEDHHINC # Median household income
)
df = st_read("data/Regression Data.shp") %>%
st_transform(crs) %>%
dplyr::select(bg_id = AREAKEY, # Block Group ID
md_housing_value = MEDHVAL, # Median Housing Value (owner-occupied)
pct_bachelor = PCTBACHMOR, # Pct of residents w/ bachelor's +
pct_vacant = PCTVACANT, # Pct of hs units that are vacant
n_poverty = NBELPOV100, # Number of hhs below poverty line
md_hh_income = MEDHHINC # Median household income
)
df = st_read("data/Regression Data.shp") %>%
st_transform(crs) %>%
dplyr::select(bg_id = AREAKEY, # Block Group ID
md_housing_value = MEDHVAL, # Median Housing Value (owner-occupied)
pct_bachelor = PCTBACHMOR, # Pct of residents w/ bachelor's +
pct_vacant = PCTVACANT, # Pct of hs units that are vacant
n_poverty = NBelPov100, # Number of hhs below poverty line
md_hh_income = MEDHHINC # Median household income
)
View(df)
rm(hs_value)
gc()
# Dictionary of variable names to their meaningful names
var_dct = c("bg_id" = "Block Group ID",
"md_housing_value" = "Median Housing Value",
"pct_bachelor" = "Pct of Residents w/ Bachelor's Degree +",
"pct_vacant" = "Pct of Housing Units Being Vacant",
"n_poverty" = "# of Households under Poverty Line",
"md_hh_income" = "Median Household Income")
knitr::opts_chunk$set(echo=TRUE, cache=FALSE, results="hide", message=FALSE, warning=FALSE)
# Several libraries and util functions from my GitHub
source("https://raw.githubusercontent.com/Leejere/r-setup/main/r_setup.r")
# Some other libraries to be used
library(Hmisc)
library(rgeoda)
library(BAMMtools)
library(DAAG)
library(car)  #to calculate VIF
library(MASS)
library(rsq)
# A 5-scale palette based off of the hero palette color
palette_blue_5 = list('#ffffff', '#c6c7eb', '#8e8fd7', '#5557c3', '#353797')
?glm
knitr::opts_chunk$set(echo=TRUE, cache=FALSE, results="hide", message=FALSE, warning=FALSE)
df = st_read("data/Regression Data.shp") %>%
st_transform(crs) %>%
dplyr::select(bg_id = AREAKEY, # Block Group ID
md_housing_value = MEDHVAL, # Median Housing Value (owner-occupied)
pct_bachelor = PCTBACHMOR, # Pct of residents w/ bachelor's +
pct_vacant = PCTVACANT, # Pct of hs units that are vacant
n_poverty = NBelPov100, # Number of hhs below poverty line
md_hh_income = MEDHHINC, # Median household income
pct_single = PCTSINGLES # Pct of hs units that are single-family detached
)
# Several libraries and util functions from my GitHub
source("https://raw.githubusercontent.com/Leejere/r-setup/main/r_setup.r")
df = st_read("data/Regression Data.shp") %>%
st_transform(crs) %>%
dplyr::select(bg_id = AREAKEY, # Block Group ID
md_housing_value = MEDHVAL, # Median Housing Value (owner-occupied)
pct_bachelor = PCTBACHMOR, # Pct of residents w/ bachelor's +
pct_vacant = PCTVACANT, # Pct of hs units that are vacant
n_poverty = NBelPov100, # Number of hhs below poverty line
md_hh_income = MEDHHINC, # Median household income
pct_single = PCTSINGLES # Pct of hs units that are single-family detached
)
# Dictionary of variable names to their meaningful names
var_dct = c("bg_id" = "Block Group ID",
"md_housing_value" = "Median Housing Value",
"pct_bachelor" = "Pct of Residents w/ Bachelor's Degree +",
"pct_vacant" = "Pct of Housing Units Being Vacant",
"n_poverty" = "# of Households under Poverty Line",
"md_hh_income" = "Median Household Income",
"pct_single" = "Pct of Housing Unites Single Family Detached")
df <- df %>%
mutate(n_poverty_log = log(n_poverty + 1))
var_dct <-
var_dct %>% append("n_poverty_log" = "Logged # of Households under Poverty Line")
View(df)
var_dct <-
var_dct %>% add("n_poverty_log" = "Logged # of Households under Poverty Line")
plot(df, col='grey90', lwd=2)
xy<-coordinates(df)
queen<-poly2nb(df, row.names=df$POLY_ID)
summary(queen)
View(queen)
plot(df, col='grey90', lwd=2)
xy<-coordinates(df)
par(mfrow=c(1,1))
plot(queen, xy, col='red', lwd=2, add=TRUE)
?coordinates
View(df)
typeof(df)
plot(df, col='grey90', lwd=2)
xy<-coordinates(as_Spatial(df))
par(mfrow=c(1,1))
plot(queen, xy, col='red', lwd=2, add=TRUE)
title(main='Contiguous Queen Neighbors')
#see which region has only one neighbor
smallestnbcard<-card(queen) #extract neighbor matrix
smallestnb<-which(smallestnbcard == min(smallestnbcard)) #extract block groups with smallest number of neighbors
fg<-rep('grey90', length(smallestnbcard))
fg[smallestnb]<-'red' #color block groups red
fg[queen[[smallestnb[1]]]]<-'green' #color neighboring blocks green
fg[queen[[smallestnb[2]]]]<-'green'
fg[queen[[smallestnb[3]]]]<-'green'
fg[queen[[smallestnb[4]]]]<-'green'
plot(shp, col=fg)
#see which region has only one neighbor
smallestnbcard<-card(queen) #extract neighbor matrix
smallestnb<-which(smallestnbcard == min(smallestnbcard)) #extract block groups with smallest number of neighbors
fg<-rep('grey90', length(smallestnbcard))
fg[smallestnb]<-'red' #color block groups red
fg[queen[[smallestnb[1]]]]<-'green' #color neighboring blocks green
fg[queen[[smallestnb[2]]]]<-'green'
fg[queen[[smallestnb[3]]]]<-'green'
fg[queen[[smallestnb[4]]]]<-'green'
plot(df, col=fg)
title(main='Regions with only 1 neighbor')
plot(df, col='grey90', lwd=2)
xy<-coordinates(as_Spatial(df %>% select(geometry)))
# create the queen weight dataframe
queen<-poly2nb(df, row.names=df$bg_id)
summary(queen)
# plot continuous queen neighbors
plot(df, col='grey90', lwd=2)
xy<-coordinates(as_Spatial(df %>% select(bg_id)))
smallestnbcard<-card(queen) #extract neighbor matrix
smallestnb<-which(smallestnbcard == min(smallestnbcard)) #extract block groups with smallest number of neighbors
fg<-rep('grey90', length(smallestnbcard))
fg[smallestnb]<-'red' #color block groups red
fg[queen[[smallestnb[1]]]]<-'green' #color neighboring blocks green
fg[queen[[smallestnb[2]]]]<-'green'
fg[queen[[smallestnb[3]]]]<-'green'
fg[queen[[smallestnb[4]]]]<-'green'
plot(df %>% dplyr::select(bg_id), col=fg)
title(main='Regions with only 1 neighbor')
# plot continuous queen neighbors
plot(df, col='grey90', lwd=2)
xy<-coordinates(as_Spatial(df %>% dplyr::select(bg_id)))
par(mfrow=c(1,1))
plot(queen, xy, col='red', lwd=2, add=TRUE)
title(main='Contiguous Queen Neighbors')
queen<-poly2nb(df, row.names=df$bg_id)
summary(queen)
View(queen)
smallestnbcard<-card(queen) #extract neighbor matrix
smallestnb<-which(smallestnbcard == min(smallestnbcard)) #extract block groups with smallest number of neighbors
fg<-rep('grey90', length(smallestnbcard))
fg[smallestnb]<-'red' #color block groups red
fg[queen[[smallestnb[1]]]]<-'green' #color neighboring blocks green
fg[queen[[smallestnb[2]]]]<-'green'
fg[queen[[smallestnb[3]]]]<-'green'
fg[queen[[smallestnb[4]]]]<-'green'
plot(df %>% dplyr::select(bg_id), col=fg)
title(main='Regions with only 1 neighbor')
# plot continuous queen neighbors
plot(df, col='grey90', lwd=2)
xy<-coordinates(as_Spatial(df %>% dplyr::select(bg_id)))
#par(mfrow=c(1,1))
plot(queen, xy, col='red', lwd=2, add=TRUE)
title(main='Contiguous Queen Neighbors')
queen<-poly2nb(df %>% dplyr::select(bg_id), row.names=df$bg_id)
summary(queen)
plot(df, col='grey90', lwd=2)
xy<-coordinates(as_Spatial(df %>% dplyr::select(bg_id)))
#par(mfrow=c(1,1))
plot(queen, xy, col='red', lwd=2, add=TRUE)
title(main='Contiguous Queen Neighbors')
plot(df %>% dplyr::select(bg_id), col='grey90', lwd=2)
xy<-coordinates(as_Spatial(df %>% dplyr::select(bg_id)))
#par(mfrow=c(1,1))
plot(queen, xy, col='red', lwd=2, add=TRUE)
title(main='Contiguous Queen Neighbors')
# create the queen weight dataframe
queen<-poly2nb(df , row.names=df$bg_id)
summary(queen)
# plot continuous queen neighbors
plot(df %>% dplyr::select(bg_id), col='grey90', lwd=2)
xy<-coordinates(as_Spatial(df %>% dplyr::select(bg_id)))
#par(mfrow=c(1,1))
plot(queen, xy, col='red', lwd=2, add=TRUE)
title(main='Contiguous Queen Neighbors')
# plot continuous queen neighbors
plot(df %>% dplyr::select(bg_id), col='grey90', lwd=2)
xy<-coordinates(as_Spatial(df))
par(mfrow=c(1,1))
plot(queen, xy, col='red', lwd=2, add=TRUE)
title(main='Contiguous Queen Neighbors')
plot(df %>% dplyr::select(bg_id), col='grey90', lwd=2)
xy<-coordinates(as_Spatial(df))
par(mfrow=c(1,1))
plot(queen, xy, col='red', lwd=10, add=TRUE)
title(main='Contiguous Queen Neighbors')
largestnbcard<-card(queen)
largestnb<-which(largestnbcard == max(largestnbcard))
fg1<-rep('grey90', length(largestnbcard))
fg1[largestnb]<-'red'
fg1[queen[[largestnb]]]<-'green'
plot(df, col=fg1)
title(main='Region with 27 neighbors')
largestnbcard<-card(queen)
largestnb<-which(largestnbcard == max(largestnbcard))
fg1<-rep('grey90', length(largestnbcard))
fg1[largestnb]<-'red'
fg1[queen[[largestnb]]]<-'green'
plot(df %>% dplyr::select(bg_id), col=fg1)
title(main='Region with 27 neighbors')
colnames(df)
queenlist<-nb2listw(queen, style = 'W')
moran(df$md_housing_value, queenlist, n=length(queenlist$neighbours), S0=Szero(queenlist))$`I`
#Run local moran's I (LISA)
LISA<-localmoran(df$md_housing_value, queenlist)
head(LISA)
#Run local moran's I (LISA)
LISA<-localmoran(df$md_housing_value, queenlist)
head(LISA)
df.LISA <-cbind(df, as.data.frame(LISA))
moranSig.plot<-function(df,listw, title){
local<-localmoran(x=df$LNMEDHHINC, listw=listw, zero.policy = FALSE)
moran.map<-cbind(df, local)
#Here, col='Pr.z....E.Ii..' is the name of the column in the dataframe df.LISA that we're trying to plot. This variable name might change based on the version of the package.
tm<-tm_shape(moran.map)+
tm_borders(col='white')+
tm_fill(style='fixed', col='Pr.z....E.Ii..', breaks=c(0,0.001, 0.01, 0.05, 1), title= 'p-value', palette = '-BuPu')+
tm_layout(frame = FALSE, title = title)
print(tm)
}
moranSig.plot(df.LISA, queenlist, 'p-value')
#Run local moran's I (LISA)
LISA<-localmoran(df$md_housing_value, queenlist)
head(LISA)
df.LISA <-cbind(df, as.data.frame(LISA))
moranSig.plot<-function(df,listw, title){
local<-localmoran(x=df$md_housing_value, listw=listw, zero.policy = FALSE)
moran.map<-cbind(df, local)
#Here, col='Pr.z....E.Ii..' is the name of the column in the dataframe df.LISA that we're trying to plot. This variable name might change based on the version of the package.
tm<-tm_shape(moran.map)+
tm_borders(col='white')+
tm_fill(style='fixed', col='Pr.z....E.Ii..', breaks=c(0,0.001, 0.01, 0.05, 1), title= 'p-value', palette = '-BuPu')+
tm_layout(frame = FALSE, title = title)
print(tm)
}
moranSig.plot(df.LISA, queenlist, 'p-value')
install.packages("tmap")
install.packages("tmap")
library(tmap)
#Run local moran's I (LISA)
LISA<-localmoran(df$md_housing_value, queenlist)
head(LISA)
df.LISA <-cbind(df, as.data.frame(LISA))
moranSig.plot<-function(df,listw, title){
local<-localmoran(x=df$md_housing_value, listw=listw, zero.policy = FALSE)
moran.map<-cbind(df, local)
#Here, col='Pr.z....E.Ii..' is the name of the column in the dataframe df.LISA that we're trying to plot. This variable name might change based on the version of the package.
tm<-tm_shape(moran.map)+
tm_borders(col='white')+
tm_fill(style='fixed', col='Pr.z....E.Ii..', breaks=c(0,0.001, 0.01, 0.05, 1), title= 'p-value', palette = '-BuPu')+
tm_layout(frame = FALSE, title = title)
print(tm)
}
moranSig.plot(df.LISA, queenlist, 'p-value')
hl.plot<-function(df, listw){
local<-localmoran(x=df$md_housing_value, listw=listw, zero.policy = FALSE)
quadrant<-vector(mode='numeric', length=323)
m.prop<-df$md_housing_value - mean(df$md_housing_value)
m.local<-local[,1]-mean(local[,1])
signif<-0.05
quadrant[m.prop >0 & m.local>0]<-4 #high md_housing_value, high clustering
quadrant[m.prop <0 & m.local<0]<-1 #low md_housing_value, low clustering
quadrant[m.prop <0 & m.local>0]<-2 #low md_housing_value, high clustering
quadrant[m.prop >0 & m.local<0]<-3 #high md_housing_value, low clustering
quadrant[local[,5]>signif]<-0
brks <- c(0,1,2,3,4)
colors <- c("grey","light blue",'blue','pink',"red")
plot<-plot(shp,border="gray90",lwd=1.0,col=colors[findInterval(quadrant,brks,all.inside=FALSE)])
}
hl.plot(df, queenlist)
hl.plot<-function(df, listw){
local<-localmoran(x=df$md_housing_value, listw=listw, zero.policy = FALSE)
quadrant<-vector(mode='numeric', length=323)
m.prop<-df$md_housing_value - mean(df$md_housing_value)
m.local<-local[,1]-mean(local[,1])
signif<-0.05
quadrant[m.prop >0 & m.local>0]<-4 #high md_housing_value, high clustering
quadrant[m.prop <0 & m.local<0]<-1 #low md_housing_value, low clustering
quadrant[m.prop <0 & m.local>0]<-2 #low md_housing_value, high clustering
quadrant[m.prop >0 & m.local<0]<-3 #high md_housing_value, low clustering
quadrant[local[,5]>signif]<-0
brks <- c(0,1,2,3,4)
colors <- c("grey","light blue",'blue','pink',"red")
plot<-plot(df,border="gray90",lwd=1.0,col=colors[findInterval(quadrant,brks,all.inside=FALSE)])
}
hl.plot(df, queenlist)
legend("bottomright",legend=c("insignificant","low-high","low-low","high-low","high-high"),
fill=c("grey", "light blue", "blue", "pink", "red"),bty="n", cex = 0.5)
hl.plot<-function(df, listw){
local<-localmoran(x=df$md_housing_value, listw=listw, zero.policy = FALSE)
quadrant<-vector(mode='numeric', length=323)
m.prop<-df$md_housing_value - mean(df$md_housing_value)
m.local<-local[,1]-mean(local[,1])
signif<-0.05
quadrant[m.prop >0 & m.local>0]<-4 #high md_housing_value, high clustering
quadrant[m.prop <0 & m.local<0]<-1 #low md_housing_value, low clustering
quadrant[m.prop <0 & m.local>0]<-2 #low md_housing_value, high clustering
quadrant[m.prop >0 & m.local<0]<-3 #high md_housing_value, low clustering
quadrant[local[,5]>signif]<-0
brks <- c(0,1,2,3,4)
colors <- c("grey","light blue",'blue','pink',"red")
plot<-plot(df %>% dplyr::select(bg_id),border="gray90",lwd=1.0,col=colors[findInterval(quadrant,brks,all.inside=FALSE)])
}
hl.plot(df, queenlist)
legend("bottomright",legend=c("insignificant","low-high","low-low","high-low","high-high"),
fill=c("grey", "light blue", "blue", "pink", "red"),bty="n", cex = 0.5)
#Run local moran's I (LISA)
LISA<-localmoran(df$md_housing_value, queenlist)
head(LISA)
df.LISA <-cbind(df, as.data.frame(LISA))
# map the p-value districution
moranSig.plot<-function(df,listw, title){
local<-localmoran(x=df$md_housing_value, listw=listw, zero.policy = FALSE)
moran.map<-cbind(df, local)
#Here, col='Pr.z....E.Ii..' is the name of the column in the dataframe df.LISA that we're trying to plot. This variable name might change based on the version of the package.
tm<-tm_shape(moran.map)+
tm_borders(col='white')+
tm_fill(style='fixed', col='Pr.z....E.Ii..', breaks=c(0,0.001, 0.01, 0.05, 1), title= 'p-value', palette = '-BuPu')+
tm_layout(frame = FALSE, title = title)
print(tm)
}
moranSig.plot(df.LISA, queenlist, 'p-value')
# categorized p-value map
hl.plot<-function(df, listw){
local<-localmoran(x=df$md_housing_value, listw=listw, zero.policy = FALSE)
quadrant<-vector(mode='numeric', length=323)
m.prop<-df$md_housing_value - mean(df$md_housing_value)
m.local<-local[,1]-mean(local[,1])
signif<-0.05
quadrant[m.prop >0 & m.local>0]<-4 #high md_housing_value, high clustering
quadrant[m.prop <0 & m.local<0]<-1 #low md_housing_value, low clustering
quadrant[m.prop <0 & m.local>0]<-2 #low md_housing_value, high clustering
quadrant[m.prop >0 & m.local<0]<-3 #high md_housing_value, low clustering
quadrant[local[,5]>signif]<-0
brks <- c(0,1,2,3,4)
colors <- c("grey","light blue",'blue','pink',"red")
plot<-plot(df %>% dplyr::select(bg_id),border="gray90",lwd=1.0,col=colors[findInterval(quadrant,brks,all.inside=FALSE)])
}
hl.plot(df, queenlist)
legend("bottomright",legend=c("insignificant","low-high","low-low","high-low","high-high"),
fill=c("grey", "light blue", "blue", "pink", "red"),bty="n", cex = 0.5)
# calculate Global Moran'I
queenlist<-nb2listw(queen, style = 'W')
moran(df$md_housing_value, queenlist, n=length(queenlist$neighbours), S0=Szero(queenlist))$`I`
# Then check to see whether the Moran’s I value issignificant (using 999 permutations). Take a screenshot of your results to presentin your report (Moran’s I value for the sample, histogram of Moran’s I values forthe permutations, and the p-value that you obtain will need to be included).
moranMC<-moran.mc(df$md_housing_value, queenlist, nsim=999, alternative="two.sided")  #We use 999 permutations
moranMC
moranMCres<-moranMC$res
hist(moranMCres, freq=10000000, nclass=100)   #Draws distribution of Moran's I's calculated from randomly permuted values
# Here, we draw a red vertical line at the observed value of our Moran's I
abline(v=moran(df$md_housing_value, queenlist, n=length(queenlist$neighbours), S0=Szero(queenlist))$`I`, col='red')
moran.plot(df$md_housing_value, queenlist)
