"n_poverty" = "# of Households under Poverty Line",
"md_hh_income" = "Median Household Income",
"pct_single" = "Pct of Housing Unites Single Family Detached")
colnames(df)
df <- df %>%
mutate(n_poverty_log = log(n_poverty + 1))
# var_dct <-
#   var_dct %>% add("n_poverty_log" = "Logged # of Households under Poverty Line")
df <-  st_read("data/Regression Data.shp") %>%
st_transform(crs) %>%
dplyr::select(bg_id = AREAKEY, # Block Group ID
md_housing_value = MEDHVAL,
md_housing_value_log = LNMEDHVAL,# Median Housing Value (owner-occupied)
pct_bachelor = PCTBACHMOR, # Pct of residents w/ bachelor's +
pct_vacant = PCTVACANT, # Pct of hs units that are vacant
n_poverty = NBelPov100, # Number of hhs below poverty line
md_hh_income = MEDHHINC, # Median household income
pct_single = PCTSINGLES # Pct of hs units that are single-family detached
) %>%
mutate(n_poverty_log = log(n_poverty + 1))
# Dictionary of variable names to their meaningful names
var_dct = c("bg_id" = "Block Group ID",
"md_housing_value" = "Median Housing Value",
"md_housing_value_log" = "Logged Median Housing Value",
"pct_bachelor" = "Pct of Residents w/ Bachelor's Degree +",
"pct_vacant" = "Pct of Housing Units Being Vacant",
"n_poverty" = "# of Households under Poverty Line",
"md_hh_income" = "Median Household Income",
"pct_single" = "Pct of Housing Unites Single Family Detached")
colnames(df)
#Setting an adaptive bandwidth
bw<-gwr.sel(formula=md_housing_value_log~n_poverty_log + pct_bachelor +
pct_single + pct_vacant,
data=df,
method = "aic",
adapt = TRUE)
library(spgwr)
install.packages("spgwr")
library(spgwr)
#Setting an adaptive bandwidth
bw<-gwr.sel(formula=md_housing_value_log~n_poverty_log + pct_bachelor +
pct_single + pct_vacant,
data=df,
method = "aic",
adapt = TRUE)
typeof(df)
library(spgwr)
#Setting an adaptive bandwidth
bw<-gwr.sel(formula=md_housing_value_log~n_poverty_log + pct_bachelor +
pct_single + pct_vacant,
data=as_Spatial(df),
method = "aic",
adapt = TRUE)
# gwr model with adpative bandwidth
gwrmodel<-gwr(formula=md_housing_value_log~n_poverty_log + pct_bachelor +
pct_single + pct_vacant,
data= as_Spatial(df),
adapt = bw, #adaptive bandwidth determined by proportion of observations accounted for
gweight=gwr.Gauss,
se.fit=TRUE, #to return local standard errors
hatmatrix = TRUE)
gwrmodel
summary(gwrmodel$SDF)
gwrresults<-as.data.frame(gwrmodel$SDF)
View(gwrresults)
colnames(gwrresults)
df <- df %>%
mutate(coef_n_poverty_log_st = gwrresults$n_poverty_log/gwrresults$n_poverty_log_se,
coef_pct_vacant_st = gwrresults$pct_vacant / gwrresults$pct_vacant_se,
coef_pct_bachelor_st = gwrresults$pct_bachelor / gwrresults$pct_bachelor_se,
coef_pct_single = gwrresults$pct_single/gwrresults$pct_single_se)
df <- df %>%
mutate(coef_n_poverty_log_st = gwrresults$n_poverty_log/gwrresults$n_poverty_log_se,
coef_pct_vacant_st = gwrresults$pct_vacant / gwrresults$pct_vacant_se,
coef_pct_bachelor_st = gwrresults$pct_bachelor / gwrresults$pct_bachelor_se,
coef_pct_single = gwrresults$pct_single/gwrresults$pct_single_se,
gwrE = gwrresults$gwr.e,
localR2 = gwrresults$localR2)
# plotting
coef_n_poverty_log<-tm_shape(df)+
tm_fill(col='coef_n_poverty_log_st', breaks=c(-Inf, -6, -4, -2, 0, 2, 4, 6, Inf), title='Standardized coefficient of n_poverty_log',
palette ='-RdBu')+
tm_layout(frame=FALSE, title = 'Number of Poverty (Log(')
coef_pct_vacant<-tm_shape(df)+
tm_fill(col='coef_pct_vacant_st', breaks=c(-Inf, -6, -4, -2, 0, 2, 4, 6, Inf), title='Standardized coefficient of pct_vacant',
palette='-RdBu')+
tm_layout(frame=FALSE, title = 'Percentage of Housing Vacant')
coef_pct_bachelor<-tm_shape(df)+
tm_fill(col='coef_bachelor_st', breaks=c(-Inf, -6, -4, -2, 0, 2, 4, 6, Inf), title='Standardized coefficient of pct_bachelor',
palette ='-RdBu')+
tm_layout(frame=FALSE, title = 'Percentage of bachelor degree or more')
coef_pct_single<-tm_shape(df)+
tm_fill(col='coef_pct_single_st', breaks=c(-Inf, -6, -4, -2, 0, 2, 4, 6, Inf), title='Standardized coefficient of pct_single',
palette ='-RdBu')+
tm_layout(frame=FALSE, title = 'Percentage of single family housing')
tmap_arrange(coef_n_poverty_log, coef_pct_bachelor, coef_pct_single, coef_pct_vacant, ncol=2)
?tmap_arrange
plot_list = list(coef_n_poverty_log, coef_pct_bachelor, coef_pct_single)
tmap_arrange(plot_list, coef_pct_vacant, ncol=2)
tm_shape(df)+
tm_fill(col='coef_n_poverty_log_st', breaks=c(-Inf, -6, -4, -2, 0, 2, 4, 6, Inf), title='Standardized coefficient of n_poverty_log',
palette ='-RdBu')+
tm_layout(frame=FALSE, title = 'Number of Poverty (Log(')
coef_pct_vacant<-tm_shape(df)+
tm_fill(col='coef_pct_vacant_st', breaks=c(-Inf, -6, -4, -2, 0, 2, 4, 6, Inf), title='Standardized coefficient of pct_vacant',
palette='-RdBu')+
tm_layout(frame=FALSE, title = 'Percentage of Housing Vacant')
df <- df %>%
mutate(coef_n_poverty_log_st = gwrresults$n_poverty_log/gwrresults$n_poverty_log_se,
coef_pct_vacant_st = gwrresults$pct_vacant / gwrresults$pct_vacant_se,
coef_pct_bachelor_st = gwrresults$pct_bachelor / gwrresults$pct_bachelor_se,
coef_pct_single = gwrresults$pct_single/gwrresults$pct_single_se,
gwrE = gwrresults$gwr.e,
localR2 = gwrresults$localR2)
tm_shape(df)+
tm_fill(col='coef_pct_vacant_st', breaks=c(-Inf, -6, -4, -2, 0, 2, 4, 6, Inf), title='Standardized coefficient of pct_vacant',
palette='-RdBu')+
tm_layout(frame=FALSE, title = 'Percentage of Housing Vacant')
tm_shape(df)+
tm_fill(col='coef_bachelor_st', breaks=c(-Inf, -6, -4, -2, 0, 2, 4, 6, Inf), title='Standardized coefficient of pct_bachelor',
palette ='-RdBu')+
tm_layout(frame=FALSE, title = 'Percentage of bachelor degree or more')
coef_pct_bachelor<-tm_shape(df)+
tm_fill(col='coef_pct_bachelor_st', breaks=c(-Inf, -6, -4, -2, 0, 2, 4, 6, Inf), title='Standardized coefficient of pct_bachelor',
palette ='-RdBu')+
tm_layout(frame=FALSE, title = 'Percentage of bachelor degree or more')
coef_pct_single<-tm_shape(df)+
tm_fill(col='coef_pct_single_st', breaks=c(-Inf, -6, -4, -2, 0, 2, 4, 6, Inf), title='Standardized coefficient of pct_single',
palette ='-RdBu')+
tm_layout(frame=FALSE, title = 'Percentage of single family housing')
plot_list = list(coef_n_poverty_log, coef_pct_bachelor, coef_pct_single)
tmap_arrange(plot_list, coef_pct_vacant, ncol=2)
tm_shape(df)+
tm_fill(col='coef_pct_single_st', breaks=c(-Inf, -6, -4, -2, 0, 2, 4, 6, Inf), title='Standardized coefficient of pct_single',
palette ='-RdBu')+
tm_layout(frame=FALSE, title = 'Percentage of single family housing')
df <- df %>%
mutate(coef_n_poverty_log_st = gwrresults$n_poverty_log/gwrresults$n_poverty_log_se,
coef_pct_vacant_st = gwrresults$pct_vacant / gwrresults$pct_vacant_se,
coef_pct_bachelor_st = gwrresults$pct_bachelor / gwrresults$pct_bachelor_se,
coef_pct_single_st = gwrresults$pct_single/gwrresults$pct_single_se,
gwrE = gwrresults$gwr.e,
localR2 = gwrresults$localR2)
# plotting
coef_n_poverty_log<-tm_shape(df)+
tm_fill(col='coef_n_poverty_log_st', breaks=c(-Inf, -6, -4, -2, 0, 2, 4, 6, Inf), title='Standardized coefficient of n_poverty_log',
palette ='-RdBu')+
tm_layout(frame=FALSE, title = 'Number of Poverty (Log)')
coef_pct_vacant<-tm_shape(df)+
tm_fill(col='coef_pct_vacant_st', breaks=c(-Inf, -6, -4, -2, 0, 2, 4, 6, Inf), title='Standardized coefficient of pct_vacant',
palette='-RdBu')+
tm_layout(frame=FALSE, title = 'Percentage of Housing Vacant')
coef_pct_bachelor<-tm_shape(df)+
tm_fill(col='coef_pct_bachelor_st', breaks=c(-Inf, -6, -4, -2, 0, 2, 4, 6, Inf), title='Standardized coefficient of pct_bachelor',
palette ='-RdBu')+
tm_layout(frame=FALSE, title = 'Percentage of bachelor degree or more')
coef_pct_single<-tm_shape(df)+
tm_fill(col='coef_pct_single_st', breaks=c(-Inf, -6, -4, -2, 0, 2, 4, 6, Inf), title='Standardized coefficient of pct_single',
palette ='-RdBu')+
tm_layout(frame=FALSE, title = 'Percentage of single family housing')
plot_list <-  list(coef_n_poverty_log, coef_pct_bachelor, coef_pct_single)
tmap_arrange(plot_list, coef_pct_vacant, ncol=2)
plot_list <-  list(coef_n_poverty_log, coef_pct_bachelor, coef_pct_single，coef_pct_vacant)
plot_list <-  list(coef_n_poverty_log, coef_pct_bachelor, coef_pct_single, coef_pct_vacant)
tmap_arrange(plot_list,  ncol=2)
colnames(df)
?scale_fill_manual
# All the variables for the maps
choropleth_var_list = c("coef_n_poverty_log_st", "coef_pct_vacant_st", "coef_pct_single_st",
"coef_pct_bachelor_st")
# Create a list of the real names
choropleth_name_list = c()
for(var in choropleth_var_list){
if(substring(var, nchar(var) - 6, nchar(var)) == "_log_st"){
choropleth_name_list = c(choropleth_name_list,
paste0("Log ",
var_name_dict[substring(var, 1, nchar(var) - 4)]))
} else {
choropleth_name_list = c(choropleth_name_list,
paste0(var_name_dict[var]))
}
}
var_dict = c("bg_id" = "Block Group ID",
"md_housing_value" = "Median Housing Value",
"md_housing_value_log" = "Logged Median Housing Value",
"pct_bachelor" = "Pct of Residents w/ Bachelor's Degree +",
"pct_vacant" = "Pct of Housing Units Being Vacant",
"n_poverty" = "# of Households under Poverty Line",
"md_hh_income" = "Median Household Income",
"pct_single" = "Pct of Housing Unites Single Family Detached",
"n_poverty_log" = "Logged number of Households under Poverty Line")
choropleth_var_list = c("coef_n_poverty_log_st", "coef_pct_vacant_st", "coef_pct_single_st",
"coef_pct_bachelor_st")
# # Create a list of the real names
# choropleth_name_list = c()
# for(var in choropleth_var_list){
#   if(substring(var, nchar(var) - 6, nchar(var)) == "_log_st"){
#     choropleth_name_list = c(choropleth_name_list,
#                              paste0("Log ",
#                                     var_dict[substring(var, 1, nchar(var) - 4)]))
#   } else {
#     choropleth_name_list = c(choropleth_name_list,
#                              paste0(var_dict[var]))
#   }
# }
choropleth_name_list <- c()
for (var in choropleth_var_list) {
var_short <- gsub("coef_", var)
var_short <- gsub("_st", var_short)
choropleth_name_list = c(choropleth_name_list, paste0(var_dict[var]))
}
choropleth_name_list <- c()
for (var in choropleth_var_list) {
var_short <- gsub("coef_", var)
var_short <- gsub("_st", var_short)
choropleth_name_list = c(choropleth_name_list, paste0(var_dict[var_short]))
}
choropleth_name_list <- c()
for (var in choropleth_var_list) {
var_short <- gsub("coef_", var)
var_short <- gsub("_st", var_short)
#choropleth_name_list = c(choropleth_name_list, paste0(var_dict[var_short]))
}
choropleth_name_list <- c()
for (var in choropleth_var_list) {
var_short <- gsub("coef_", "", var)
var_short <- gsub("_st","", var_short)
choropleth_name_list = c(choropleth_name_list, paste0(var_dict[var_short]))
}
map_list <-  list()
# Make a long table
df <-  df %>%
dplyr::select(bg_id, choropleth_var_list) %>%
gather("Legend", "Value", -blockgroup_id, -geometry)
df_long <-  df %>%
dplyr::select(bg_id, choropleth_var_list) %>%
gather("Legend", "Value", -bg_id, -geometry)
# Make the plots
for(i in seq(1,length(choropleth_var_list))){
var = choropleth_var_list[i]
this_sf = df_long %>% filter(., Legend == var)
map_list[[var]] =
ggplot(this_sf) +
geom_sf(aes(fill = to_jenks_cats(Value, 5)), color = NA) +
scale_fill_manual(values = palette_blue_5,
#labels = to_jenks_labels(this_df$Value, 5),
breaks = c(-6, -4, -2, 0, 2, 4, 6),
name = "") +
labs(title = choropleth_name_list[i]) +
map_theme(title_size = 9, tick_size = 7) +
theme(legend.position = c(0.8, 0.25))
}
do.call(grid.arrange, c(map_list[2:5], ncol = 2, top = "Choropleth Maps"))
# Make the plots
for(i in seq(1,length(choropleth_var_list))){
var = choropleth_var_list[i]
this_sf = df_long %>% filter(., Legend == var)
map_list[[var]] =
ggplot(this_sf) +
geom_sf(aes(fill = Value), color = NA) +
scale_fill_manual(values = palette_blue_5,
#labels = to_jenks_labels(this_df$Value, 5),
breaks = c(-6, -4, -2, 0, 2, 4, 6),
name = "") +
labs(title = choropleth_name_list[i]) +
map_theme(title_size = 9, tick_size = 7) +
theme(legend.position = c(0.8, 0.25))
}
do.call(grid.arrange, c(map_list[2:5], ncol = 2, top = "Choropleth Maps"))
scale_fill_continuous()
?scale_fill_continuous
?scale_fill_continuous()
# Initialize map list
map_list <-  list()
# Make a long table
df_long <-  df %>%
dplyr::select(bg_id, choropleth_var_list) %>%
gather("Legend", "Value", -bg_id, -geometry)
# Make the plots
for(i in seq(1,length(choropleth_var_list))){
var = choropleth_var_list[i]
this_sf = df_long %>% filter(., Legend == var)
map_list[[var]] =
ggplot(this_sf) +
geom_sf(aes(fill = Value), color = NA) +
scale_fill_continuous(type = "viridis",
#labels = to_jenks_labels(this_df$Value, 5),
breaks = c(-6, -4, -2, 0, 2, 4, 6),
name = "") +
labs(title = choropleth_name_list[i]) +
map_theme(title_size = 9, tick_size = 7) +
theme(legend.position = c(0.8, 0.25))
}
do.call(grid.arrange, c(map_list[2:5], ncol = 2, top = "Choropleth Maps"))
map_list <-  list()
# Make a long table
df_long <-  df %>%
dplyr::select(bg_id, choropleth_var_list) %>%
gather("Legend", "Value", -bg_id, -geometry)
# Make the plots
for(i in seq(1,length(choropleth_var_list))){
var = choropleth_var_list[i]
this_sf = df_long %>% filter(., Legend == var)
map_list[[var]] =
ggplot(this_sf) +
geom_sf(aes(fill = Value), color = NA) +
scale_fill_continuous(type = "viridis",
#labels = to_jenks_labels(this_df$Value, 5),
breaks = c(-6, -4, -2, 0, 2, 4, 6),
name = "") +
labs(title = choropleth_name_list[i]) +
map_theme(title_size = 9, tick_size = 7) +
theme(legend.position = c(0.8, 0.25))
}
do.call(grid.arrange, c(map_list, ncol = 2, top = "Choropleth Maps"))
# Make the plots
for(i in seq(1,length(choropleth_var_list))){
var = choropleth_var_list[i]
this_sf = df_long %>% filter(., Legend == var)
map_list[[var]] =
ggplot(this_sf) +
geom_sf(aes(fill = Value), color = NA) +
scale_fill_continuous(type = "gradient",
#labels = to_jenks_labels(this_df$Value, 5),
breaks = c(-6, -4, -2, 0, 2, 4, 6),
name = "") +
labs(title = choropleth_name_list[i]) +
map_theme(title_size = 9, tick_size = 7) +
theme(legend.position = c(0.8, 0.25))
}
do.call(grid.arrange, c(map_list, ncol = 2, top = "Choropleth Maps"))
knitr::opts_chunk$set(echo=TRUE, cache=FALSE, results="hide", message=FALSE, warning=FALSE)
# Several libraries and util functions from my GitHub
source("https://raw.githubusercontent.com/Leejere/r-setup/main/r_setup.r")
library(tmap)
df <-  st_read("data/Regression Data.shp") %>%
st_transform(crs) %>%
dplyr::select(bg_id = AREAKEY, # Block Group ID
md_housing_value = MEDHVAL,
md_housing_value_log = LNMEDHVAL,# Median Housing Value (owner-occupied)
pct_bachelor = PCTBACHMOR, # Pct of residents w/ bachelor's +
pct_vacant = PCTVACANT, # Pct of hs units that are vacant
n_poverty = NBelPov100, # Number of hhs below poverty line
md_hh_income = MEDHHINC, # Median household income
pct_single = PCTSINGLES # Pct of hs units that are single-family detached
) %>%
mutate(n_poverty_log = log(n_poverty + 1),
md_hh_income_log = log(md_hh_income + 1))
# Dictionary of variable names to their meaningful names
var_dict = c("bg_id" = "Block Group ID",
"md_housing_value" = "Median Housing Value",
"md_housing_value_log" = "Logged Median Housing Value",
"pct_bachelor" = "Pct of Residents w/ Bachelor's Degree +",
"pct_vacant" = "Pct of Housing Units Being Vacant",
"n_poverty" = "# of Households under Poverty Line",
"md_hh_income" = "Median Household Income",
"pct_single" = "Pct of Housing Unites Single Family Detached",
"n_poverty_log" = "Logged number of Households under Poverty Line",
"md_hh_income_log" = "Logged Median Household Income")
# create the queen weight dataframe
queen<-poly2nb(df, row.names=df$bg_id)
summary(queen)
# plot continuous queen neighbors
plot(df %>% dplyr::select(bg_id), col='grey90', lwd=2)
xy<-coordinates(as_Spatial(df))
par(mfrow=c(1,1))
plot(queen, xy, col='red', lwd=10, add=TRUE)
title(main='Contiguous Queen Neighbors')
#see which region has only one neighbor
smallestnbcard<-card(queen) #extract neighbor matrix
smallestnb<-which(smallestnbcard == min(smallestnbcard)) #extract block groups with smallest number of neighbors
fg<-rep('grey90', length(smallestnbcard))
fg[smallestnb]<-'red' #color block groups red
fg[queen[[smallestnb[1]]]]<-'green' #color neighboring blocks green
fg[queen[[smallestnb[2]]]]<-'green'
fg[queen[[smallestnb[3]]]]<-'green'
fg[queen[[smallestnb[4]]]]<-'green'
plot(df %>% dplyr::select(bg_id), col=fg)
title(main='Regions with only 1 neighbor')
#see which region has most neighbors
largestnbcard<-card(queen)
largestnb<-which(largestnbcard == max(largestnbcard))
fg1<-rep('grey90', length(largestnbcard))
fg1[largestnb]<-'red'
fg1[queen[[largestnb]]]<-'green'
plot(df %>% dplyr::select(bg_id), col=fg1)
title(main='Region with 27 neighbors')
# Generalist the queen list for moran's I
queenlist<-nb2listw(queen, style = 'W')
# calculate Global Moran'I
morans_i = moran(df$md_housing_value, queenlist, n=length(queenlist$neighbours), S0=Szero(queenlist))$`I`
# Then check to see whether the Moran’s I value is significant (using 999 permutations). Take a screenshot of your results to presentin your report (Moran’s I value for the sample, histogram of Moran’s I values forthe permutations, and the p-value that you obtain will need to be included).
moranMC<-moran.mc(df$md_housing_value, queenlist, nsim=999, alternative="two.sided")  #We use 999 permutations
# Plot the hypothetical Moran's Is under the 999 permutations and plot the observed moran's I
ggplot(as.data.frame(moranMC$res[c(1:999)]), aes(moranMC$res[c(1:999)])) +
geom_histogram(binwidth = 0.002, fill = palette_hero_faded) +
# Observed Moran's I
geom_vline(aes(xintercept = morans_i), color = palette_hero, size = 1) +
labs(x="Moran's I under 999 permutations", y="Count", title = "Permutated and Observed Moran's I") +
annotate("text", x=0.58, y=10, label = "Observed\nMoran's I:\n" %>% paste0(morans_i %>% round(2)),
hjust = 0) +
plot_theme()
#Create Moran plot (lagged value against observed value)
df$lag_housing_value = lag.listw(queenlist, df$md_housing_value)
ggplot(df, aes(x=md_housing_value, y=lag_housing_value)) +
geom_point(color=palette_hero_faded, size=0.5) +
geom_smooth(method = "lm", color=palette_hero) +
labs(x="Median Housing Value", y="Lagged Median Housing Value (Queen)",
title="Median Housing Value Is Highly Spatially Autocorrelated") +
plot_theme()
#Run local moran's I (LISA)
LISA<-localmoran(df$md_housing_value, queenlist)
# Resulting an sf stating Local Moran's Is
df.LISA <-cbind(df, as.data.frame(LISA))
# map the p-value districution
df.LISA = df.LISA %>%
mutate(p_value =
case_when(Pr.z....E.Ii.. < 0.001 ~ "0.000 to 0.001",
Pr.z....E.Ii.. < 0.010 ~ "0.001 to 0.010",
Pr.z....E.Ii.. < 0.050 ~ "0.010 to 0.050",
TRUE ~ "0.050 to 1.000"),
p_value = factor(p_value,
levels = c("0.000 to 0.001",
"0.001 to 0.010",
"0.010 to 0.050",
"0.050 to 1.000")))
df.LISA %>%
ggplot(aes(fill=p_value)) +
geom_sf(color="#FFFFFF", size=0.2) +
scale_fill_manual(values=c(palette_hero, palette_hero_faded, palette_water, "#dddddd"),
name = "P-Value") +
map_theme()
# categorized p-value map
mean_value = mean(df$md_housing_value, na.rm=TRUE)
mean_lisa = mean(LISA[,1], na.rm=TRUE)
df.LISA = df.LISA %>%
mutate(category =
case_when(Pr.z....E.Ii.. > 0.05 ~ "Insignificant",
md_housing_value >= mean_value & Ii >= mean_lisa ~ "High-High",
md_housing_value >= mean_value & Ii < mean_lisa ~ "High-Low",
md_housing_value < mean_value & Ii >= mean_lisa ~ "Low-High",
TRUE ~ "Low-Low"),
category = factor(category,
levels = c("High-High", "High-Low", "Low-High", "Low-Low", "Insignificant")))
df.LISA %>%
ggplot(aes(fill = category)) +
geom_sf(color="#FFFFFF", size=0.2) +
scale_fill_manual(values = c(palette_primary, palette_primary_faded,
palette_hero, palette_hero_faded,
"#dddddd"),
name = "Categories") +
map_theme()
fit <- lm(md_housing_value_log ~ pct_vacant + pct_single
+ pct_bachelor + n_poverty_log,
data = df %>% st_drop_geometry())
summary(fit)
library(lmtest)
# Breusch-Pagan Test
bptest(fit, studentize=FALSE)
# Koenker-Bassett Test
bptest(fit, studentize=TRUE)
library(whitestrap)
# White test
white_test(fit)
library(tseries)
jarque.bera.test(fit$residuals)
# First standardize the OLS regression residuals
res_standardized = rstandard(fit)
# Then get the lagged residuals
res_lag = lag.listw(queenlist, res_standardized)
# Plot
cbind(res_standardized, res_lag) %>%
as.data.frame() %>%
ggplot(aes(x=res_lag, y=res_standardized)) +
geom_point(color=palette_hero_faded, size=1) +
geom_smooth(method="lm", color=palette_hero) +
labs(x="Lagged residuals", y="Standardized residuals") +
plot_theme()
res_fit = lm(res_standardized ~ res_lag)
summary(res_fit)
# Plot the hypothetical Moran's Is under the 999 permutations and plot the observed moran's I
ggplot(as.data.frame(moranMC$res[c(1:999)]), aes(moranMC$res[c(1:999)])) +
geom_histogram(binwidth = 0.002, fill = palette_hero_faded) +
# Observed Moran's I
geom_vline(aes(xintercept = morans_i), color = palette_hero, size = 1) +
labs(x="Moran's I under 999 permutations", y="Count", title = "Permutated and Observed Moran's I") +
annotate("text", x=0.58, y=10, label = "Observed\nMoran's I:\n" %>% paste0(morans_i %>% round(2)),
hjust = 0) +
plot_theme()
ggplot(df, aes(x=md_housing_value, y=lag_housing_value)) +
geom_point(color=palette_hero_faded, size=0.5) +
geom_smooth(method = "lm", color=palette_hero) +
labs(x="Median Housing Value", y="Lagged Median Housing Value (Queen)",
title="Median Housing Value Is Highly Spatially Autocorrelated") +
plot_theme()
logLik(fit)
lag_reg = lagsarlm(md_housing_value_log ~ pct_vacant + pct_single
+ pct_bachelor + n_poverty_log,
data = df %>% st_drop_geometry())
lag_reg = lagsarlm(md_housing_value_log ~ pct_vacant + pct_single
+ pct_bachelor + n_poverty_log,
data = df %>% st_drop_geometry()，
queenlist)
lag_reg = lagsarlm(md_housing_value_log ~ pct_vacant + pct_single
+ pct_bachelor + n_poverty_log,
data = df %>% st_drop_geometry(),
queenlist)
summary(lag_reg)
bptest(lag_reg)
bptest.Sarlm(lag_reg)
bptest.Sarlm(lag_reg)
bptest.sarlm(lag_reg)
bptest.sarlm(lag_reg, studentize = FALSE)
jarque.bera.test(lag_reg$residuals)
lrtest(lag_reg, fit)
knitr::opts_chunk$set(echo=TRUE, cache=FALSE, results="hide", message=FALSE, warning=FALSE)
summary(fit)
bptest.sarlm(lag_reg, studentize = FALSE)
# Several libraries and util functions from my GitHub
source("https://raw.githubusercontent.com/Leejere/r-setup/main/r_setup.r")
library(tmap)
library(lmtest)
library(whitestrap)
# Breusch-Pagan Test
bptest(fit, studentize=FALSE)
bptest.sarlm(lag_reg, studentize = FALSE)
bptest.sarlm(lag_reg, studentize = TRUE)
LR.sarlm(lag_reg, fit)
lag_reg.residual
lag_reg.residuals
View(lag_reg)
lag_reg$residuals
lag_residuals = lag_reg$residuals
residuals = lag_reg$residuals
residuals_lag = lag.listw(queenlist, residuals)
residuals = rstandard(lag_reg)
residuals = lag_reg$residuals %>% scale(.)
residuals
residuals_lag = lag.listw(queenlist, residuals)
cbind(residuals, residuals_lag) %>%
as.data.frame() %>%
ggplot(aes(x=residuals_lag, y=residuals)) +
geom_point(color=palette_hero_faded, size=1) +
geom_smooth(method="lm", color=palette_hero) +
labs(x="Lagged residuals", y="Standardized residuals") +
plot_theme()
knitr::opts_chunk$set(echo=TRUE, cache=FALSE, results="hide", message=FALSE, warning=FALSE)
# Several libraries and util functions from my GitHub
source("https://raw.githubusercontent.com/Leejere/r-setup/main/r_setup.r")
library(tmap)
library(spgwr)
#Setting an adaptive bandwidth
bw<-gwr.sel(formula=md_housing_value_log~n_poverty_log + pct_bachelor +
pct_single + pct_vacant,
data=as_Spatial(df),
method = "aic",
adapt = TRUE)
bw
# create a fixed bandwidth
bw_fixed<-gwr.sel(formula=md_housing_value_log~n_poverty_log + pct_bachelor +
pct_single + pct_vacant,
data=as_Spatial(df),
method = "aic",
adapt = FALSE)
bw_fixed
# gwr model with adpative bandwidth
gwrmodel<-gwr(formula=md_housing_value_log~n_poverty_log + pct_bachelor +
pct_single + pct_vacant,
data= as_Spatial(df),
adapt = bw, #adaptive bandwidth determined by proportion of observations accounted for
gweight=gwr.Gauss,
se.fit=TRUE, #to return local standard errors
hatmatrix = TRUE)
gwrmodel
# gwr model with fixed bandwidth
gwrmodel_fixed<-gwr(formula=md_housing_value_log~n_poverty_log + pct_bachelor +
pct_single + pct_vacant,
data= as_Spatial(df),
adapt = bw_fixed, #adaptive bandwidth determined by proportion of observations accounted for
gweight=gwr.Gauss,
se.fit=TRUE, #to return local standard errors
hatmatrix = TRUE)
